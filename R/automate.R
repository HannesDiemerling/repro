#' Automate the use of Docker & Make
#'
#' `automate()` & friends use yaml metadata from RMarkdowns to create
#' `Dockerfile`'s and `Makefile`'s. It should be clear which is created by
#' `automate_docker()` & which by `automate_make()`.
#' @param path Where should we look for RMarkdowns?
#' @seealso [automate_load_packages()], [automate_load_data()], [automate_load_scripts()]
#' @name automate
NULL

#' @rdname automate
#' @export
automate <- function(path = "."){
  automate_docker(path)
  automate_make(path)
  return(invisible(NULL))
}

#' @rdname automate
#' @export
automate_make <- function(path = "."){
  if(automate_dir()){
    yamls <- get_yamls(path)

  }
  usethis::ui_oops("Sorry {usethis::ui_code('automate_make')} not implemented, yet.")
}

get_output_file <- function(file, output){
  get_fun <- function(x) {
    # from https://stackoverflow.com/a/38984214/7682760
    if(grepl("::", x)) {
      parts<-strsplit(x, "::")[[1]]
    } else {
      parts <- c("rmarkdown", x)
    }
    getExportedValue(parts[1], parts[2])
  }
  render_func <- do.call(get_fun(output), list())
  do.call(utils::getFromNamespace("pandoc_output_file", "rmarkdown"),
          list(input = file,
               pandoc_options = render_func$pandoc))
}

#' @rdname automate
#' @export
automate_docker <- function(path = "."){
  if(automate_dir()){
    dockerfile_base <- paste0(getOption("repro.dir"),
                              "/",
                              getOption("repro.dockerfile.base"))
    dockerfile_packages <- paste0(getOption("repro.dir"),
                                  "/",
                                  getOption("repro.dockerfile.packages"))
    dockerfile_manual <- paste0(getOption("repro.dir"),
                                "/",
                                getOption("repro.dockerfile.manual"))
    # handle base
    if(!fs::file_exists(dockerfile_base))use_docker(file = dockerfile_base,
                                                    open = FALSE)
    # handle packages
    docker_packages <- use_docker_packages(
      yamls_packages(path = usethis::proj_path(path)),
      file = dockerfile_base,
      write = FALSE,
      append = FALSE
    )
    xfun::write_utf8(docker_packages, dockerfile_packages)
    # handle manual
    if(!fs::file_exists(dockerfile_manual))fs::file_create(dockerfile_manual)

    # bundle dockerfiles
    automate_docker_bundle()
  }
}

automate_docker_bundle <- function(file = "Dockerfile"){
  dockerfiles <- c(
    dockerfile_base = usethis::proj_path(
      getOption("repro.dir"),
      getOption("repro.dockerfile.base")
    ),
    dockerfile_manual = usethis::proj_path(
      getOption("repro.dir"),
      getOption("repro.dockerfile.manual")
    ),
    dockerfile_packages = usethis::proj_path(
      getOption("repro.dir"),
      getOption("repro.dockerfile.packages")
    )
  )
  note <- glue::glue("# Generated by repro: do not edit by hand
# Please edit Dockerfiles in {getOption('repro.dir')}/")
  to_write <- c(note, unlist(lapply(dockerfiles, xfun::read_utf8)))
  xfun::write_utf8(to_write, file)
}

automate_dir <- function(dir, warn = FALSE, create = !warn){
  if(missing(dir))dir <- getOption("repro.dir")
  dir_full <- usethis::proj_path(dir)
  exists <- fs::dir_exists(dir_full)
  if(!exists){
    if(warn){
      usethis::ui_oops("Directory {usethis::ui_code(dir)} does not exist!")
    }
    if(create){
      fs::dir_create(dir_full)
      usethis::ui_done("Directory {usethis::ui_code(dir)} created!")
      exists <- TRUE
    }
  }
  return(exists)
}

#' Access repro YAML Metadata from within the document
#'
#' * `automate_load_packages()` loads all packages listed in YAML via `library()`
#' * `automate_load_scripts()` registeres external scripts via `knitr::read_chunk()`
#' * `automate_load_data()` reads in the data from the yaml with abitrary functions
#'
#' @param data How is the entry in the YAML called? It will be the name of the object.
#' @param func Which function should be used to read in the data? Its first argument must be the path to the file.
#' @param ... Further arguments supplied to `func`.
#' @return `automate_load_packages()` & `automate_load_scripts()` do not return anything. `automate_load_data()` returns the data.
#'
#' @name automate_load
NULL

#' @rdname automate_load
#' @export
automate_load_packages <- function(){
  packages <- yaml_repro_current()$packages
  lapply(packages, library, character.only = TRUE, quietly = TRUE)
  return(invisible(NULL))
}

#' @rdname automate_load
#' @export
automate_load_scripts <- function(){
  paths <- lapply(yaml_repro_current()$scripts, usethis::proj_path)
  scripts <- lapply(paths, xfun::read_utf8)
  lapply(scripts, function(x)knitr::read_chunk(lines = x))
  return(invisible(NULL))
}

#' @rdname automate_load
#' @export
automate_load_data <- function(data, func, ...){
  which <- deparse(substitute(data))
  path <- usethis::proj_path(yaml_repro_current()$data[[which]])
  data <- do.call(func, list(path, ...))
  return(data)
}
